---
title: "fcScan: feature clustering Scan"
author:
- name: Pierre Khoueiry
  affiliation: 
  - &id1 American University of Beirut, Beirut, Lebanon
  email: pk17@aub.edu.lb
- name: Abdallah El-Kurdi
  affiliation: 
  - *id1
  email: ak161@aub.edu.lb
- name: Ghiwa Khalil
  affiliation: 
  - *id1
- name: Georges Khazen
  affiliation: Lebanese American University, Byblos, Lebanon
  email: gkhazen@lau.edu.lb
vignette: >
  %\VignetteIndexEntry{fcScan}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF8}
output: BiocStyle::html_document
---

```{r style, echo=FALSE, results='asis'}
BiocStyle::markdown()
```


# Version Info
```{r, echo=FALSE, results="hide", warning=FALSE}
suppressPackageStartupMessages({library('fcScan')})
```
<p>
**R version**: `r R.version.string`
<br />
**Bioconductor version**: `r BiocInstaller::biocVersion()`
<br />
**Package version**: `r packageVersion("fcScan")`
</p>

```{r, setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

# Introduction
Biological information encoded in the DNA sequence is often organized into
independent modules or clusters. For instance, the eukaryotic system of
expression relies on combinations of homotypic or heterotypic transcription
factors (TFs) which play an important role in activating and repressing
target genes. Identifying clusters of genomic features is a frequent task and
includes application such as identifying enhancers and genomic regions enriched
for the presence of a combination of transcription factor binding sites or
enriched for the presence of mutations often referred as regions with increase
mutational hotspots.

fcScan is designed to detect clusters of genomic features, as mentioned aboved,
based on user defined search criteria. Such criteria include:  
    
* A list of BED/VCF files or a dataframe or a GRanges object as input (required)  
* A window size of the clusters to identify (required)  
* The combination of features required (i.e TFBS) (required)  
* The order of features required within identified clusters (optional)  
* The distance required between identified clusters (optional)  
* The strand(s) to build the clusters on (optional)  
* The seqname(s) to build the clusters on (optional)  

fcScan is designed to handle large number of genomic features (i.e such as 
data generated by High Throughput Sequencing).

# Dependencies
fcScan depends on the following packages:

* **stats**
* **utils**
* **rtracklayer**
* **SummarizedExperiment**
* **VariantAnnotation**
* **GenomicRanges**

# Overview
Currently, fcScan has one main function, the `getCluster` function. Additional
functionality may be added in the future including cross-species identication of
orthologous clusters.


# Input arguments for getCluster

## Input data (x)
The input for `getCluster` is given through the parameter `x`.
This function accepts files in BED and VCF (compressed or not) formats. BED and
VCF files are loaded by packages `rtracklayer` and `VariantAnnotation` 
respectively. There is no limit to the number of files the user can define.

Alternatively, `getCluster` accepts a data frame or a GRanges object as input.
When a data frame is given, it should contain the following "named" 5 columns:

* **seqnames** : Contains the seqname name
* **start**: Contains the start coordinates
* **end**: Contains the end coordinates
* **strand**: Contains the strand relative to each site
* **site** : Contains the category name relative to genomic site

```{r, echo=FALSE, results='asis'}
df <- data.frame(seqnames = c("chr1", "chr1", "chr1", "chr1", "chr1", "chr1"),
                 start = c(10, 17, 25, 27, 32, 41), 
                 end=c(15, 20, 30, 35, 40, 48),
                 strand = c("+", "+", "+", "+", "+", "+"),
                 site = c("a", "b", "b", "a", "c", "b"))

knitr::kable(df)
```

The *seqnames*, *start* and *end* columns are the relative positions of each
feature/site.
The *site* column contains the ID of the site and will be used for clustering.
THe *start* and *end* columns are numeric while the remaining columns are 
characters.

## Window Size (w)
Window size is set using `w`, and this parameter defines the `maximum` size of
the clusters.

## Condition &#40;c)
The clustering condition `c` defines the number and type of genomic data to 
search for in each cluster based on the information in the `site` column
`c = c("a" = 1, "b" = 2)`  
This searches for clusters with 3 sites, One *a* site and two  *b* sites.

Another way of writing the condition is the following 
`x = ("a.bed","b.bed"), c = c(1,2)`  
Given 2 files, *a.bed* and *b.bed*, this condition states that the user is 
looking for clusters made from 1 "a" site and 2 "b" sites. In this case, the
order of sites defined in `c` is relative to the order of files.

In case the input is a data frame or GRanges (instead of files), the user needs
to **explicitly** define the site name along with the count relative to each
site. 
Giving the condition as `c = c(1,2)` for a data frame or GRanges will not be allowed.  
`x = dataFrame_of_sites, c = c("a" = 1, "b" = 2)` where `a`
 and `b` are valid site names in the `site`

Users can exclude sites from their cluster. this is specified by zero `0`
 in the condition as `c = c("a" = 1, "b" = 2, "c" = 0)`, meaning that if any cluster
 contains "c" site will not be considered as cluster.

## Seqnames (seqnames) and Strand (s).
By default, clustering will be performed on both strands and on all seqnames
unless specified by the user using the `s` and `seqnames` arguments to limit the
search on a specific strand or seqname.

Users can choose to cluster on one specific seqname `(seqnames = "chr1")`, or
on more than one seqname `(seqnames = c("chr1","chr3","chr4"))`  
(Default of `seqnames` is **NULL**) meaning that clustering on all seqnames 
will be performed.

For `s`, the values allowed are: 

* **+** : Build clusters on positive strand
* **-** : Build clusters on negative strand
* **\*** : Clusters are not strand specific  
(Default is set to **\***)
	
## Overlap (overlap)
The gap/overlap between adjacent clusters, and not sites, can be controled using
the `overlap` option.
When `overlap` is positive, adjacent clusters will be separated by a minimum
of the given value.
When `overlap` is negative, adjacent clusters will be allowed to overlap by
a maximum of the given value. (Default is set to **0**)

## Greedy vs Non-Greedy (greedy)
`greedy` allows the user to control the number of genomic features found 
in clusters.

When `greedy = FALSE`, `getCluster` will build clusters having the required
window size and will label *TRUE* the ones that contain the **exact** number
and type of sites provided in the condition argument.
Clusters having the user defined window size but not satisfying
the condition will be labelled as *FALSE*.

When `greedy = TRUE`, additional sites will be added to the cluster as
long as the cluster size is below the defined  window size.
(Default is set to **TRUE**)  


## Order (order)
The `order` option allows the user to define the specific order for the
combination of sites required.  
Given the order in the above example to be :
`order = c("a","b","b")`
This will search for a cluster containing the above sites in the exact same 
order. They can be a sub order of a larger cluster (i.e when greedy is TRUE)
or simply a cluster containing these sites.
For example if a cluster has "a, a, b, b, b" sites, this cluster has the
required order (a, b, b) and therefore will be considered as a correct
cluster if greedy is TRUE. (Default is set to **NULL**)

## Verbose (verbose)
The `verbose` option allows the printing of additional messages and the
list of clusters that failed for lack of correct combination of sites.
This option is used mainly for debugging purpose. (Default is set to FALSE)

# Output of getCluster

The output of `getCluster` is a GRanges object with fields:

* **seqnames**: The seqname on which a cluster is found
* **ranges**: The ranges of the cluster
* **strand**: The strand of the cluster, if any
* **sites**: The combination of sites that define the cluster
* **isCluster**: A logical indicating if the cluster is TRUE or FALSE
* **status**: Describes the reason behind the rejection of a cluster 



The algorithm returns all clusters containing the correct count of
sites/features. If the combination, overlap, and order options are satisfied,
the cluster is considered a `TRUE` cluster. 

*status* of a cluster might be either PASS, ExcludedSites or orderFail.
`PASS` is a cluster that satisfied the desired order and combination.
`orderFail` is a cluster that had the required combination but did not
have the required order of sites.
`ExcludedSites` is a cluster that had the required order and combination but
 but it has excluded sites.

NOTE: If the user is using `greedy = FALSE` and `order` contains values more
than in the condition parameter (`c`),  an error will be raised.
However, if `greedy = TRUE`, then using `order` with more values than the 
condition parameter is allowed since the cluster may contain more 
sites than the required `c` condition as long as the window size is satisfied.


# Example on Clustering

Example using `getCluster`:

```{r, eval=FALSE} 
x = data.frame(seqnames = rep("chr1", times = 16),
    start = c(10,17,25,27,32,41,47,60,70,87,94,99,107,113,121,132),
    end = c(15,20,30,35,40,48,55,68,75,93,100,105,113,120,130,135),
    strand = rep("+", 16),
    site = c("s1","s2","s2","s1","s2","s1","s1","s2","s1","s2","s2",
             "s1","s2","s1","s1","s2"))

clusters = getCluster(x, w = 25, c = c("s1"=1,"s2"=2),
	greedy = TRUE, overlap = -5, s = "+", order = c("s1","s2","s1"))
```

# Session Info

```{r} 
sessionInfo() 
``` 

