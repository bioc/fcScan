---
title: "fcScan"
author:
- Pierre Khoueiry
- Ghiwa Khalil
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
package: fcScan
vignette: >
  %\VignetteEngine{knitr::rmarkdown}  
  %\VignetteIndexEntry{fcScan}  
  %\VignetteEncoding{UTF-8}
---

```{r, setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```


## Table of Contents
* [Introduction](#introduction) 
* [Install Packages](#Install Packages) 
* [Packages Needed](#Packages Needed)  
* [Overview](#Overview)
* [Input data as BED/VCF files or dataframe](#Input data as BED/VCF files or dataframe)  
* [Setting the clustering condition](#Setting the clustering condition)  
* [Greedy vs Non-Greedy ](#Greedy vs Non-Greedy)  
* [Example on Clustering](#Example on Clustering)  
* [Example on Mapping](#Example on Mapping)  
* [Parallelism](#Parallelism)  
* [Plotting Mapped Clusters using Rcircos](#Plotting Mapped Clusters using Rcircos)  
* [Session Info](#Session Info)


## <a id="introduction"></a> Introduction

Biological information encoded in the DNA sequene is often organized into
independent modules or clusters. For instance, the eukaryotic system of
expression relies on combinations of homotypic or heterotypic transcription
factors (TFs) which play an important role in activating and repressing
target genes.

In disease state, genomics regions with increased mutational hotspots are
associated with disease initiation and progression.

fcScan is a package designed to detect clusters of genomic features based on 
user defined search criteria. Such criteria include:  
    
	-A list of BED/VCF files or a dataframe of input data __
    -The required window size of the clusters to identify __
	-The combination of features required from input files or dataframe __
	-The order of features required within identified clusters
	-The distance required between each cluster   
    -On which strand to build the clusters   
    -On which chromosome to build the clusters   

Additionally, fcScan package contains a wrapper function around
*pslMap* from KentUtilsallowing the user to detect orthologous regions
from identified clusters. 


## <a id="Packages Needed"></a> Packages Needed

fcScan requires the following packages to be installed for the 
usage of getCluster :

    parallel
    doParallel
    foreach
    stats
    utils

mapCluster requires to have "pslMap" and "bedToPsl" from kent utilities

kent utilities can be downloaded from the following
website [https://github.com/ENCODE-DCC/kentUtils]
It is impprtant to note that not all operating systems
support kent utils, and so the mapCluster functionality of fcScan will
not run on all operating systems. This does not affect the main function
in fcScan "getCluster" that aims at identifying clusters of genomic
features.

## <a id="Install Packages"></a> Install Packages

    install.packages("parallel")
    install.packages("doParallel")
    install.packages("foreach")
    install.packages("stats")
	install.packages("utils")
    
Chain files can be downloaded from  [http://hgdownload.cse.ucsc.edu/downloads.html]

Chrom.sizes file can be found at [http://hgdownload.soe.ucsc.edu/goldenPath/**/bigZips]

"**" Should be replaced by the species(ex. hg19) 
    
## <a id="Overview"></a> Overview

**Clustering** is done using the `getCluster` function based on user
defined arguments.

By default, the clusters will be built on both strands and all chromosomes
unless specified by the user using the `chr` and `str` arguments to limit the
search on a specific chromosome or strand.

The gap/overlap between adjacent clusters can be controled using the `overlap`
option.
When positive, adjacent clusters will be separated by a minimum of the
given value.
When negative, adjacent clusers will be allowed to overlap by the a maximum
of the given value
(Default is 0).

The `greedy` option allows the user to search for clusters with the required
number and only the required number of features (`greedy = FALSE`).
When set to `TRUE`, larger clusters will be returned as long as they contain 
the combination of sites requested in `c` or more (Default is TRUE).

The `order` option allows the user to define the specific order for the
combination of sites required. (Default is **NULL**).

The output will be a data frame with fields containing the:

`chr`: The chromosome on which a cluster is found
`start`: The start of the cluster
`end`: The end of the cluster
`size`: The size of the cluster
`sites`: The combination of sites that defines the cluster
`strand`: The strand of the cluster, if any
`isCluster`: A logical indicating if the cluster is TRUE or FALSE
`reason`: Describes the reason behind the rejection of a cluster 

The algorithm returns all clusters containing the correct count of
sites/features. If the combination, overlap, and order options are satisfied,
the cluters is considered a `TRUE` cluster. 

NOTE: If the user is using `greedy = FALSE` and `order` contains values more
than  in the condition parameter,  an error will be raised.
However, if `greedy = TRUE`, then using `order** with more values than the 
condition paramerter is allowed since a greedy cluster may contain more 
sites than the required condition.

The `mapCluster` function is a wrapper around kent utility pslMap, mostly 
adapted for identifying orthologous regions for distantly related species.
It is required to have `pslMap` and `bedToPsl` from KentUtils installed in
order to us `mapCluster`.
The path to kent utils can be specified as argument unless they are in
the system path.
Additionally, this function requires a chain file for both `species` that
the user wants to map


## <a id="Input data as BED/VCF files or dataframe"></a> Input data as BED/VCF files or dataframe

`getCluster` takes BED and VCF files (compressed or not). BED-12, BED-6, BED-4,
and Bed-3 file formats are valid.
There is no limit on the number of files the user can define.

>`clusters = getCluster(x=c("~/project/fcScan/data/NANOG.bed","~/project/fcScan/data/TATA.bed"), w = 1500, c = c("NANOG"=1,"TATA"=2), greedy = TRUE, overlap = -5, str = "+", chr = "chr9")`


Alternatively, `getCluster` accepts a data frame as input. In this case,
this data frame should have 5 columns containing the following.
    
`chr start end strand  site`

The chr, start and end columns are the relative position of each feature/site.
The site column contains the ID of the site and will be used for clustering.
start and end columns are numeric while the rest are characters.

```{r, echo=FALSE, results='asis'}
df <- data.frame(chr = c("chr1", "chr1", "chr1", "chr1", "chr1", "chr1"),
                 start = c(10, 17, 25, 27, 32, 41), 
                 end=c(15, 20, 30, 35, 40, 48),
                 strand = c("+", "+", "+", "+", "+", "+"),
                 site = c("1", "2", "2", "1", "3", "2"))

knitr::kable(df)
```

## <a id = "Setting the clustering condition"></a> Setting the clustering condition

The clustering condition `c` defines the number and type of genomic data to 
search for in each cluster.
`c = c("TATA" = 1, "GATA" = 2)`  
This searches for clusters with 3 sites, One *TATA* and two  *GATA*.

Another way of writing the condition is the following : 
`x = ("TATA.bed","GATA.bed"), c = c(1,2)`  
Given 2 files, *TATA.bed* and *GATA.bed*, this condition states that the user is 
looking for clusters made from 1 TATA site and 2 GATA sites. The numbers 
given in the condition are relative to the order of the files given. 

In case a data frame is given instead of files, the user needs to **explicitly** 
defines the site name along with the number relative to each site. 
Giving the condition as `c = c(1,2)` for a data frame will not be allowed.

## <a id = "Greedy vs Non-Greedy"></a> Greedy vs Non-Greedy 

When `greedy = FALSE`, `getCluster` will build clusters having the required
window size and will label *TRUE* the ones that contain the exact number
and type of genomic data provided in the condition argument.
Clusters having the user defined window size but not satisfying
the condition will be labelled as *FALSE*.

`greedy = TRUE` will look for clusters having the required window size
and will label *TRUE* the ones that contain the required condition of the
genomic data or more. The rest will be labelled as *FALSE*. 


## <a id = "Example on Clustering"></a> Example on Clustering

Following will be an example of how to use `getCluster` function.
This is an example of a data frame given instead of files.

The data can be downloaded from the following link [http://compbio.mit.edu/encode-motifs/]

This contains all known and discovered motifs for the ENCODE TFChIP-seq datasets

In this example, `getCluster` was performed on the NANOG_known1 motif
and TATA_known2 motif.
`motif.txt` is a large file so it would be more efficient to handle
it from the terminal using bash, to extract the required sites.


To get the sites for each motif :
    
    
> `grep -i "NANOG_known1" matches.txt > "NANOG_known1.txt"`
> `grep -i "TATA_known2" matches.txt > "TATA_known2.txt"`

Read each file into R

> `NANOG = read.table("/home/gk39/tmp/NANOG_known1.txt", stringsAsFactors = FALSE)`
> `TATA = read.table("/home/gk39/tmp/TATA_known2.txt", stringsAsFactors = FALSE)`

Rearrange the columns to have the required data frame

> `TATA = TATA[,c("V2","V3","V4","V5","V1")]`
> `NANOG = NANOG[,c("V2","V3","V4","V5","V1")]`  
> `head(TATA)`



```{r, echo=FALSE, results='asis'}
df <- data.frame(chr = c("chr1", "chr1", "chr1", "chr1", "chr1", "chr1"), 
                 start = c(25705L, 65916L, 119982L, 167008L, 266303L, 343330L), 
                 end = c(25719L, 65930L, 119996L, 167022L, 266317L, 343344L), 
                 strand = c("+", "-", "-", "+", "-", "+"),
                 site = c("TATA_known2", "TATA_known2", "TATA_known2", 
                          "TATA_known2", "TATA_known2", 
                          "TATA_known2"))

knitr::kable(df)
```

>`head(NANO)`


```{r, echo=FALSE, results='asis'}
df <- data.frame(chr = c("chr1", "chr1", "chr1", "chr1", "chr1", "chr1"), 
                 start = c(89192L, 93669L, 235753L, 239997L, 363873L, 415307L), 
                 end = c(89203L, 93680L, 235764L, 240008L, 363884L, 415318L), 
                 strand = c("+", "+", "+", "+", "-", "-"), 
                 site = c("NANOG_known1", "NANOG_known1", "NANOG_known1", 
                          "NANOG_known1", "NANOG_known1", "NANOG_known1"))

knitr::kable(df)
```

>`x = rbind(TATA,NANOG)`
>`colnames(x) = c("chr","start","end","strand","site")`



In the example below `getCluster` will search for clusters that contain a
minimum of 1 NANOG_known1 site and 2 TATA_known2 sites, found within 1000bp,
and adjacent clusters should be seperated by a maximum of 5 overlapping base
pairs.
Since `chr` has the value `chr9` and `str` has the value `+`, clusters will
only be built on chromosome 9 only and for sites defined on the positive strand
exclusively.

>`clusters = getCluster(x , w = 20000 , c = c("NANOG_known1" = 1, "TATA_known2" = 2 ), overlap = -5, chr = "chr9", str = "+")`

The results are stored in a data frame named clusters. *clusters* contains 
1606 observations with 8 variables


>`head(clusters)`

```{r, echo=FALSE, results='asis'}
df <- data.frame(chr = c("chr9", "chr9", "chr9", "chr9", "chr9", "chr9"), 
                 start = c("25818", "165838", "202789", "253853", "361625", 
                           "387687"), 
                 end = c("25832", "165852", "202800", "253867", "361639",
                         "387701"), 
                 clusterSize = c("14", "14", "11", "14", "14", "14"), 
                 site = c("TATA_known2", "TATA_known2", "NANOG_known1", 
                          "TATA_known2", "TATA_known2", "TATA_known2"), 
                 strand = c("+", "+", "+", "+", "+", "+"), 
                 isCluster = c("FALSE", "FALSE", "FALSE", "FALSE", "FALSE",
                               "FALSE"), 
                 name = c("c1", "c2", "c3", "c4", "c5", "c6"))

knitr::kable(df)
```

The resulting data frame will contain the *TRUE* and *FALSE* labelled 
clusters. To get only the cluster labelled by *TRUE*
    We can subset by the following:
    
> `subset(clusters, isCluster %in% TRUE)`  
> `head(clusters)`


```{r, echo=FALSE, results='asis'}
df <- data.frame(chr = c("chr9", "chr9", "chr9", "chr9", "chr9", "chr9"), 
                 start = c("5831141", "9319579", "16533736", "21748099",
                           "23403001", "23714517"), 
                 end = c("5846962", "9331595", "16549756", "21753346",
                         "23415107", "23728984"), 
                 clusterSize = c("15821", "12016", "16020", "5247",
                                 "12106", "14467"), 
                 site = c("TATA_known2,TATA_known2,NANOG_known1",
                          "NANOG_known1,TATA_known2,TATA_known2",
                          "TATA_known2,TATA_known2,NANOG_known1", 
                          "TATA_known2,NANOG_known1,TATA_known2",
                          "NANOG_known1,TATA_known2,TATA_known2", 
                          "TATA_known2,NANOG_known1,TATA_known2"), 
                 strand = c("+", "+", "+", "+", "+", "+"), 
                 isCluster = c("TRUE", "TRUE", "TRUE", "TRUE", "TRUE", "TRUE"), 
                 name = c("c94", "c138", "c253", "c331", "c347", "c354"))

knitr::kable(df)
```

*clusters_TRUE* contains 20 observations with 8 variables.


## <a id = "Example on Mapping"></a> Example on Mapping

This package includes a function that can map orthologous regions 
between species using pslMap from kentUtils. 

`mapCluster(x , kent, chrom.sizes, chain)`
*x* is a data frame that contains the mapped clusters, the rest of the
arguments are the path to kentUtils, to chrom.sizes file and to chain
file being used. 

By default, the path to kent is set to NULL assuming path to kentUtils is in the
system path.
Otherwise, user the path needs to be specified in the option **kent**.

`mapClusters` takes a Bed-6 format, and so must have the following columns:
    
    > chr   start   end name    score   strand  site


So, to use our clusters we got from `getClusters` function, we need to a *score*
column.
We are going to use the data frame which contains the clusters labbelled *TRUE*
to map the clusters which satisfied all the user defined conditions.

> `clusters_TRUE = clusters_TRUE[,c("chr", "start", "end", "id", "score", "strand")]`  
> `mapCluster( clusters_TRUE , chrom.sizes = "hg19.chrom.sizes", chain = "hg19ToMm10.over.chain")`

```{r, echo=FALSE, results='asis'}
df <- data.frame(SeqNames = c("chr19", "chr4", "chr4", "chr4", 
                              "chr4", "chr4", "chr4", "chr4",
                              "chr4", "chr4", "chr4", "chr4", 
                              "chr4", "chr13", "chr13", "chr13",
                              "chr4", "chr4", "chr4", "chr2"
), 
Start = c(29646385L, 76914893L, 84373653L, 89096005L, 90906555L, 
          91272473L, 92895457L, 35596995L, 36196127L, 36932006L, 39138272L, 
          71162604L, 71231574L, 51843935L, 52807767L, 52864104L, 55687810L, 
          64208514L, 68827355L, 28663311L), 
End = c(29664014L, 76930788L, 
    84386597L, 89099760L, 90918616L, 91279251L, 92912899L, 35625610L, 
    36211595L, 36949651L, 39159397L, 71167158L, 71260811L, 51860444L, 
    52818892L, 52879722L, 55701839L, 64238113L, 68850614L, 28670470L
          ), 
Strand = c("+", "+", "+", "+", "+", "+", "+", "+", "+", "+", 
           "+", "+", "+", "+", "+", "+", "+", "+", "+", "-"), 
srcTName = c("chr9", 
             "chr9", "chr9", "chr9", "chr9", "chr9", "chr9", "chr9", "chr9", 
             "chr9", "chr9", "chr9", "chr9", "chr9", "chr9", "chr9", "chr9", 
             "chr9", "chr9", "chr9"), 
srcTStart = c(5831141L, 9319579L, 16533736L, 
              21748099L, 23403001L, 23714517L, 25254361L, 27890002L, 28420039L, 
              29192740L, 31384498L, 83422179L, 83497976L, 92216608L, 93938820L, 
              94030069L, 110452876L, 118041889L, 122001846L, 135788286L), 
srcTEnd = c(5846962L, 
        9331595L, 16549756L, 21753346L, 23415107L, 23728984L, 25268779L, 
        27899866L, 28433306L, 29211468L, 31402419L, 83435687L, 83517867L, 
        92234756L, 93955288L, 94048072L, 110465819L, 118057829L, 122020632L, 
                        135799106L), 
srcStrand = c("+", "+", "+", "+", "+", "+", "+", 
              "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+"
))

knitr::kable(df)
```

The result of `mapClusters` is a data frame which contains 207 observations and 
8 variables. The above example is only a small sample of the results.

In the example above, we mapped the clusters from hg19 to Mm10.

*SeqNames Start End Strand* are the representative information of the mapped
regions in the mice species.
*srcTName srcTStart srcTEnd srcStrand* are the representative information of
the clustered regions.

The columns on the left represent the mapped orthologous regions corresponding
to the regions on the right.
In the 10th row, the *SeqNames* is empty, and the *Start* and *End* region are
represented by **--**. 

This indicates that for this cluster, there was no orthologous region detected
in mm10.

## <a id="Parallelism"></a> Parallelism

This package uses parallelism by chromosome. One core will be allocated
per chromosome.
The number of cores is set to 2 by default.


## <a id = "Plotting Mapped Clusters using Rcircos"></a> Plotting Mapped Clusters using Rcircos

Using Rcircos, you can plot the resulting mapping from mapClusters.
*mappedClusters* is the data frame that contains the mapped clusters.

```
library(RCircos)
human.data = mappedClusters[,5:8]
mouse.data = mappedClusters[,1:4]
data(UCSC.Mouse.GRCm38.CytoBandIdeogram)
data(UCSC.HG19.Human.CytoBandIdeogram)

link.data <- data.frame(human.data[,1:3], mouse.data[,1:3])

species.list <- c("H", "M")

link.data = link.data[-which(link.data$SeqNames ==""),]

cyto.list <- list(UCSC.HG19.Human.CytoBandIdeogram,UCSC.Mouse.GRCm38.CytoBandIdeogram)

RCircos.Multiple.Species.Core.Components(cyto.list,species.list, NULL, 5, 5)

link.data[,1] <- paste(species.list[1], link.data[,1], sep="")

link.data[,4] <- paste(species.list[2], link.data[,4], sep="")

params <- RCircos.Get.Plot.Parameters()

params$chrom.width<-0.4
params$chrom.paddings <- 2000
params$base.per.unit <- 30000

pdf(file="HumanVsMouse.pdf", height=8, width=8)
RCircos.Set.Plot.Area()
par(mai=c(0.25, 0.25, 0.25, 0.25))
plot.new()
plot.window(c(-2.5,2.5), c(-2.5, 2.5))

RCircos.Chromosome.Ideogram.Plot()

track.num<-1
RCircos.Link.Plot(link.data, track.num, FALSE)
title(" Mouse and Human Gene Expression")
legend(1, 2, legend=c("Right: Human","Left:  Mouse"), cex=0.8)
dev.off()

```

```{r pressure, echo=FALSE, fig.cap="RCircos of Mapped Clusters", out.width = '100%'}
knitr::include_graphics("./HumanVsMouse.png")
```


## <a id="Session Info"></a> Session Info


```{r} 
sessionInfo() 
``` 
