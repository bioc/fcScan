---
title: feacture clustering scan
author:
- name: Pierre Khoueiry
  affiliation:
  - &id American University of Beirut
- name: Ghiwa Khalil
  affiliation: *id
  email: pk17@aub.edu.lb
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{fcScan}
  %\VignetteEngine{knitr::rmarkdown}
output: BiocStyle::html_document
package: fcScan
---


# Version Info
```{r, echo=FALSE, results="hide", warning=FALSE}
suppressPackageStartupMessages({library('fcScan')})
```
<p>
**R version**: `r R.version.string`
<br />
**Bioconductor version**: `r BiocInstaller::biocVersion()`
<br />
**Package version**: `r packageVersion("fcScan")`
</p>

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

```{r, setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

# Introduction

Biological information encoded in the DNA sequene is often organized into
independent modules or clusters. For instance, the eukaryotic system of
expression relies on combinations of homotypic or heterotypic transcription
factors (TFs) which play an important role in activating and repressing
target genes.

In disease state, genomics regions with increased mutational hotspots are
associated with disease initiation and progression.

fcScan is a package designed to detect clusters of genomic features based on 
user defined search criteria. Such criteria include:  
    
* A list of BED/VCF files or a dataframe of input data
* The required window size of the clusters to identify
* The combination of features required from input files or dataframe
* The order of features required within identified clusters
* The distance required between identified clusters   
* The strand(s) to build the clusters on  
* The seqname(s) to build the clusters on  


# Dependencies

fcScan depends on the following packages:

* **parallel**
* **doParallel**
* **foreach**
* **stats**
* **utils**
* **rtracklayer**
* **SummarizedExperiment**
* **VariantAnnotation**
* **GenomicRanges**

# Overview

fcScan finds clusters of genomic features based on user defined 
parameters. Currently, it has one main function, the `getCluster`
function.


# Input arguments for getCluster

## Input data (x)
The input for `getCluster` is given through the parameter `x`.
This function accept files in BED and VCF (compressed or not) formats. Bed and vcf
files are loaded by packages `rtracklayer` and `VariantAnnotation` respectively.
There is no limit on the number of files the user can define.

Alternatively, `getCluster` accepts a data frame or a GRanges object as input.
When data frame is given, it should contain the following "named" 5 columns:

* **seqnames** : Contains the seqname name
* **start**: Contains start coordinates
* **end**: Contains end coordinates
* **strand**: Contains strand relative to each site
* **site** : Contains the category name relative to genomic site

```{r, echo=FALSE, results='asis'}
df <- data.frame(seqnames = c("chr1", "chr1", "chr1", "chr1", "chr1", "chr1"),
                 start = c(10, 17, 25, 27, 32, 41), 
                 end=c(15, 20, 30, 35, 40, 48),
                 strand = c("+", "+", "+", "+", "+", "+"),
                 site = c("a", "b", "b", "a", "c", "b"))

knitr::kable(df)
```

The *seqnames*, *start* and *end* columns are the relative position of each
feature/site.
The *site* column contains the ID of the site and will be used for clustering.
*start* and *end* columns are numeric while the remaining columns are characters.

## Window Size (w)
Window size is set using `w`, and this parameter defines the `maximum` size of the
clusters.

## Condition ( c)
The clustering condition `c` defines the number and type of genomic data to 
search for in each cluster based on the information in the `site` column
`c = c("a" = 1, "b" = 2)`  
This searches for clusters with 3 sites, One *a* site and two  *b* sites.

Another way of writing the condition is the following 
`x = ("a.bed","b.bed"), c = c(1,2)`  
Given 2 files, *a.bed* and *b.bed*, this condition states that the user is 
looking for clusters made from 1 "a" site and 2 "b" sites. In this case, the\
order of sites defined in `c` is relative to the order of files.

In case the input is a data frame (instead of files), the user needs to **explicitly** 
define the site name along with the count relative to each site. 
Giving the condition as `c = c(1,2)` for a data frame will not be allowed.  
`x = dataFrame_of_sites, c = c("a" = 1, "b" = 2)` where `a`
 and `b` are valid site names in the `site`
## Seqnames (seqnames) and Strand (s)
By default, clustering will be performed on both strands and all seqnames
unless specified by the user using the `s` and `seqnames` arguments to limit the
search on a specific strand or seqname.

Users can choose to cluster on one specific seqname `(seqnames = "chr1")`, or
on more than one seqname `(seqnames = c("chr1","chr3","chr4"))`  
(Default of `seqnames` is **NULL**) meaning that clustering on all seqnames 
will be performed.

For `s`, the values allowed are: 

* **+** : Build clusters on positive strand
* **-** : Build clusters on negative strand
* **.** : Clusters are not strand specific  
(Default is set to **.**)
	
## Overlap (overlap)
The gap/overlap between adjacent clusters, and not sites, can be controled using
the `overlap` option.
When `overlap` is positive, adjacent clusters will be separated by a minimum
of the given value.
When `overlap` is negative, adjacent clusers will be allowed to overlap by a maximum
of the given value. (Default is set to **0**)

## Greedy vs Non-Greedy (greedy)
`greedy` allows the user to control the number of genomic features found 
in clusters.

When `greedy = FALSE`, `getCluster` will build clusters having the required
window size and will label *TRUE* the ones that contain the **exact** number
and type of sites provided in the condition argument.
Clusters having the user defined window size but not satisfying
the condition will be labelled as *FALSE*.

When `greedy = TRUE`, additional sites will be added to the cluster as
long as the cluster size is below the defined  window size.
(Default is set to **TRUE**)  


## Order (order)
The `order` option allows the user to define the specific order for the
combination of sites required.  
Given the order in the above example to be :
`order = c("a","b","b")`
This will search for a cluster containing the above sites in the exact same order.
They can be a sub order of a larger cluster (i.e when greedy is TRUE) or simply a
cluster containing these sites.
For example if a cluster has "a, a, b, b, b" sites, this cluster has the required
order (a, b, b) and therefore will be considered as a correct cluster.
(Default is set to **NULL**)

## Number of cores (n_cores)
This parameter allows the user to control the number of cores used by 
`getCluster` when using parallel.  

This package uses parallelism by seqname. One core will be allocated 
per seqname. (Default is set to **2**)


# Output of getCluster

The output of `getCluster` is a GRanges object with fields:

* **seqnames**: The seqname on which a cluster is found
* **ranges**: The ranges of the cluster
* **strand**: The strand of the cluster, if any
* **size**: The size of the cluster
* **isCluster**: A logical indicating if the cluster is TRUE or FALSE
* **id**: An incremental ID given to identified clusters
* **status**: Describes the reason behind the rejection of a cluster 
* **sites**: The combination of sites that define the cluster
* **score**: A score of 1 is added to all the clusters to have the elements of 
(Currently this score is insignificant)

The algorithm returns all clusters containing the correct count of
sites/features. If the combination, overlap, and order options are satisfied,
the cluster is considered a `TRUE` cluster. 

*status* of a cluster might be either PASS, combnFail, or orderFail.
`PASS` is a cluster that satisfied the order and combination. `combnFail` is
a cluster that didn't satisfy the combination requirement and `orderFail` is a cluster
that had the required combination but did not have the required order of sites.

NOTE: If the user is using `greedy = FALSE` and `order` contains values more
than in the condition parameter (`c`),  an error will be raised.
However, if `greedy = TRUE`, then using `order` with more values than the 
condition paramerter is allowed since the cluster may contain more 
sites than the required `c` condition as long as the window size is satisfied.


# Example on Clustering

Example using `getCluster`:

```{r, eval=FALSE} 
x = data.frame(seqnames = rep("chr1", times = 16),
	start = c(10,17,25,27,32,41,47,60,70,87,94,99,107,113,121,132),
	end = c(15,20,30,35,40,48,55,68,75,93,100,105,113,120,130,135),
	strand = rep("+", 16),
	site = c("s1","s2","s2","s1","s2","s1","s1","s2","s1","s2","s2","s1","s2","s1","s1","s2"))

clusters = getCluster(x, w = 25, c = c("s1"=1,"s2"=2),
	greedy = TRUE, overlap = -5, s = "+", order = c("s1","s2","s1"))
```

# Session Info

```{r} 
sessionInfo() 
``` 

